name: Build and Publish Docker Image

on:
  push:
    branches:
      - main
    paths:
      - '*.Dockerfile'

  workflow_dispatch:
    inputs:
      create_changelogs:
        description: 'Create changelogs'
        required: true
        default: 'true'
      sbom_format:
        description: 'SBOM output format (e.g., json, spdx)'
        required: false
        default: 'json'
      default_bump:
        description: 'Default bump type'
        required: true
        default: 'patch'
      release_branches:
        description: 'Release branches'
        required: true
        default: 'main'
      prerelease_suffix:
        description: 'Prerelease suffix'
        required: true
        default: 'prerelease'

jobs:
  build:
    timeout-minutes: 60
    runs-on: ubuntu-latest
    permissions:
      actions: read
      packages: write
      contents: write
      id-token: write
      attestations: write
    outputs:
      new_tag: ${{ steps.next_tag.outputs.new_tag }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Determine next tag
        id: next_tag
        uses: anothrNick/github-tag-action@1.71.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DEFAULT_BUMP: ${{ github.event.inputs.default_bump }}
          RELEASE_BRANCHES: ${{ github.event.inputs.release_branches }}
          PRERELEASE_SUFFIX: ${{ github.event.inputs.prerelease_suffix }}
        continue-on-error: true  # Allow the step to fail without failing the job

      - name: Set initial tag if none exists
        if: steps.next_tag.outputs.new_tag == ''
        run: echo "::set-output name=new_tag::0.1.0"

      - name: Build Docker images
        run: |
          for dockerfile in $(find . -name "*.Dockerfile"); do
            image_name=$(basename "$dockerfile" .Dockerfile)
            echo "Building image: $image_name"
            docker build . --file "$dockerfile" --tag ${{ github.repository_owner }}/$image_name:${{ steps.next_tag.outputs.new_tag || '0.1.0' }}
          done
        env:
          BUILD_VERSION: ${{ steps.next_tag.outputs.new_tag || '0.1.0' }}

      - name: Log in to registry
        run: echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin

      - name: Push version tagged Docker images to Github packages
        id: push
        run: |
          find . -name "*.Dockerfile" -exec sh -c 'docker tag ${{ github.repository_owner }}/$(basename {} .Dockerfile):${{ steps.next_tag.outputs.new_tag || '0.1.0' }}' \;
          find . -name "*.Dockerfile" -exec sh -c 'docker push ghcr.io/${{ github.repository_owner }}/$(basename {} .Dockerfile):${{ steps.next_tag.outputs.new_tag || '0.1.0' }}' \;

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3.8.1
        with:
          cosign-release: 'v2.4.3'

      - name: Check Cosign version
        run: cosign version

      - name: Create Cosign key file
        run: echo "${{ secrets.COSIGN_PRIVATE_KEY }}" > cosign.key

      - name: Sign images with a key
        run: |
          for dockerfile in $(find . -name "*.Dockerfile"); do
            image_name=$(basename "$dockerfile" .Dockerfile)
            image_tag="ghcr.io/${{ github.repository_owner }}/$image_name:${{ steps.next_tag.outputs.new_tag || '0.1.0' }}"
            echo "Signing image: $image_tag"
            image_digest=$(docker inspect --format='{{index .RepoDigests 0}}' $image_tag)
            echo "Image digest: $image_digest"
            cosign sign --yes --key cosign.key $image_digest -a "repository=${{ github.repository }}" -a "tag=${{ steps.next_tag.outputs.new_tag || '0.1.0' }}" -a "commit=${{ github.sha }}"
          done
        env:
          COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}
          BUILD_VERSION: ${{ steps.next_tag.outputs.new_tag || '0.1.0' }}

      - name: Install Syft
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin

      - name: Generate SBOM
        run: |
          for dockerfile in $(find . -name "*.Dockerfile"); do
            image_name=$(basename "$dockerfile" .Dockerfile)
            image_tag="ghcr.io/${{ github.repository_owner }}/$image_name:${{ steps.next_tag.outputs.new_tag || '0.1.0' }}"
            echo "Generating SBOM for image: $image_tag"
            syft $image_tag -o ${{ github.event.inputs.sbom_format }} > $image_name-sbom.${{ github.event.inputs.sbom_format }}
          done

      - name: Verify SBOM exists
        run: |
          for dockerfile in $(find . -name "*.Dockerfile"); do
            image_name=$(basename "$dockerfile" .Dockerfile)
            if [ ! -f "$image_name-sbom.json" ]; then
              echo "SBOM for $image_name not found!"
              exit 1
            fi
          done

      - name: Attach SBOM to image
        run: |
          for dockerfile in $(find . -name "*.Dockerfile"); do
            image_name=$(basename "$dockerfile" .Dockerfile)
            image_tag="ghcr.io/${{ github.repository_owner }}/$image_name:${{ steps.next_tag.outputs.new_tag || '0.1.0' }}"
            echo "Attaching SBOM to image: $image_tag"
            cosign attest --predicate $image_name-sbom.json --key ${{ secrets.COSIGN_PRIVATE_KEY }} $image_tag
          done
        env:
          COSIGN_PRIVATE_KEY: ${{ secrets.COSIGN_PRIVATE_KEY }}

  create-release:
    needs: [build]
    timeout-minutes: 20
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Determine next tag
        id: get_tag
        uses: anothrNick/github-tag-action@1.71.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DEFAULT_BUMP: ${{ needs.build.outputs.new_tag || github.event.inputs.default_bump }}
          RELEASE_BRANCHES: ${{ github.event.inputs.release_branches }}
          PRERELEASE_SUFFIX: ${{ github.event.inputs.prerelease_suffix }}
          DRY_RUN: true

      - name: Check for existing tags
        id: check_tags
        run: |
          if [ -z "$(git tag)" ]; then
            echo "No tags found"
            echo "has_tags=false" >> $GITHUB_ENV
          else
            echo "Tags found"
            echo "has_tags=true" >> $GITHUB_ENV
          fi

      - name: Create Changelogs
        id: create_changelogs
        if: env.has_tags == 'true'
        uses: metcalfc/changelog-generator@v4.3.1
        with:
          myToken: ${{ secrets.GITHUB_TOKEN }}

      - name: Handle missing changelog
        if: env.has_tags == 'false'
        run: echo "No changelog generated as this is a new repository."

      - name: "Release: ${{ steps.get_tag.outputs.new_tag }}"
        uses: softprops/action-gh-release@v2
        with:
          name: Release.${{ steps.get_tag.outputs.new_tag }}
          tag_name: ${{ steps.get_tag.outputs.new_tag }}
          body: ${{ steps.create_changelogs.outputs.changelog }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}